# Std-Lib Imports
from typing import Dict
from enum import Enum, auto

# Hdl & PDK Imports
import hdl21 as h

# Local Imports
from ..diff import Diff
from ..quadclock import QuadClock
from ..encoders import OneHotEncoder
from ..counter import Counter
from .pi import PhaseInterp


@h.generator
def RxDeSerializer(_: h.HasNoParams) -> h.Module:
    """ RX De-Serializer 
    Includes parallel-clock generation divider """

    m = h.Module()
    m.pdata = h.Output(width=16, desc="Parallel Output Data")
    m.sdata = h.Input(width=1, desc="Serial Input Data")
    m.pclk = h.Output(width=1, desc="*Output*, Divided Parallel Clock")
    m.sclk = h.Input(width=1, desc="Input Serial Clock")

    # Create the four-bit counter state, consisting of the parallel clock as MSB,
    # and three internal-signal LSBs.
    m.count_lsbs = h.Signal(width=3, desc="LSBs of Divider-Counterer")
    count = h.Concat(m.count_lsbs, m.pclk)

    m.counter = Counter(width=4)(clk=m.sclk, out=count)
    m.encoder = OneHotEncoder(width=4)(inp=count)

    # The bank of load-registers, all with data-inputs tied to serial data,
    # "clocked" by the one-hot counter state.
    # Note output `q`s are connected by later instance-generation statements.
    m.load_latches = 8 * Latch()(d=m.sdata, clk=m.encoder.out)
    # The bank of output flops
    m.output_flops = 8 * Flop()(d=m.load_latches.q, q=m.pdata, clk=m.pclk)

    return m


@h.module
class Cdr:
    """ 
    # Clock & Data Recovery 
    Analog / Custom Portion 
    
    While afforded a level of Module hierarchy and called "CDR", 
    this is really just the phase interpolator. 
    Control codes are to be generated by external digital logic, 
    and early/ late signals are similarly derived in the parallel digital domain. 
    """

    # IO Interface
    VDD, VSS = h.Ports(2)
    qck = QuadClock(port=True, role=QuadClock.Roles.SINK, desc="Input quadrature clock")
    dck = h.Output(desc="Recovered Data Clock")
    xck = h.Output(desc="Recovered Edge Clock")  # FIXME!
    # FIXME: make the recovered clock differential
    pi_code = h.Input(width=5, desc="Phase Interpolator Code")

    # Implementation
    pi = PhaseInterp(nbits=5)(ckq=qck, sel=pi_code, out=dck, VDD=VDD, VSS=VSS)


@h.module
class HsRx:
    """ # High-Speed Receiver """

    # IO
    # io = RxIo(port=True) # FIXME: combined bundle
    VDD, VSS = h.Ports(2)
    ## Pad Interface
    pads = Diff(desc="Differential Receive Pads", port=True, role=Diff.Roles.SINK)
    ## Core Interface
    pdata = h.Output(width=16, desc="Parallel Output Data")
    pclk = h.Output(width=1, desc="*Output*, Divided Parallel Clock")
    ## CDR
    qck = QuadClock(port=True, role=QuadClock.Roles.SINK)
    pi_code = h.Input(width=5, desc="Phase Interpolator Code")
    dck, xck = h.Outputs(2)

    # Internal Implementation
    ## Clock Recovery
    cdr = Cdr()(qck=qck, dck=dck, xck=xck, pi_code=pi_code, VDD=VDD, VSS=VSS)

    ## Slicers
    # dslicer = Slicer()(inp=pads, out=d, clk=dck)
    # xslicer = Slicer()(inp=pads, out=x, clk=xck)

    ## De-serializer, with internal parallel-clock divider
    # ddser = RxDeSerializer()(sdata=d, pdata=pdata, pclk=pclk, sclk=dck)
    # xdser = RxDeSerializer()(sdata=x, pdata=pdata, pclk=pclk, sclk=dck)
