"""
# High-Speed RX 
"""

# Hdl & PDK Imports
import hdl21 as h

# Local Imports
from ..logiccells import Latch
from ..diff import Diff
from ..quadclock import QuadClock
from .pi import PhaseInterp
from .preamp import PreAmp
from .slicer import Slicer


@h.module
class Cdr:
    """ 
    # Clock & Data Recovery 
    Analog / Custom Portion 
    
    While afforded a level of Module hierarchy and called "CDR", 
    this is really just the phase interpolator. 
    Control codes are to be generated by external digital logic, 
    and early/ late signals are similarly derived in the parallel digital domain. 
    """

    # IO Interface
    VDD, VSS = h.Ports(2)
    qck = QuadClock(port=True, role=QuadClock.Roles.SINK, desc="Input quadrature clock")
    rck = Diff(port=True, role=Diff.Roles.SOURCE, desc="Recovered Differential Clock")
    pi_code = h.Input(width=5, desc="Phase Interpolator Code")

    # Implementation
    pi = PhaseInterp(nbits=5)(ckq=qck, sel=pi_code, out=rck, VDD=VDD, VSS=VSS)


@h.module
class Slicers:
    """ # Slicer Pack 
    Including slicing for both data and edges. 
    All output data occurs on rising transitions of `rck`.  """

    # IO
    VDD18, VSS = h.Ports(2)
    inp = Diff(port=True, role=Diff.Roles.SINK)
    rck = Diff(port=True, role=Diff.Roles.SINK)
    data = h.Output(width=1, desc="Serial RX Data")
    edge = h.Output(width=1, desc="RX Edge Samples")

    # Implementation
    edge_sliced = h.Signal(desc="Edge slicer output, before retiming")
    ## Primary action: the slicers themselves
    dslicer = Slicer(inp=inp, clk=rck.p, out=data, VDD18=VDD18, VSS=VSS)
    xslicer = Slicer(inp=inp, clk=rck.n, out=edge_sliced, VDD18=VDD18, VSS=VSS)
    ## Retiming
    Latch()(d=edge_sliced, q=edge, clk=rck.p, VDD=VDD18, VSS=VSS)


@h.module
class HsRx:
    """ # High-Speed Receiver """

    # IO
    # io = RxIo(port=True) # FIXME: combined bundle
    VDD18, VDD33, VSS = h.Ports(3)
    ## Pad Interface
    pads = Diff(desc="Differential Receive Pads", port=True, role=Diff.Roles.SINK)
    ## Digital Interface
    sclk = h.Output(width=1, desc="*Output* RX Recovered Clock")
    sdata = h.Output(width=1, desc="Serial RX Data")
    edge = h.Output(width=1, desc="RX Edge Samples")
    pi_code = h.Input(width=5, desc="RX Phase Interpolator Code")
    ## CDR Quadrature Clock
    qck = QuadClock(port=False)

    # Internal Implementation
    ## Clock Recovery
    rck = Diff(port=False, desc="Recovered Differential Clock")
    cdr = Cdr()(qck=qck, rck=rck, pi_code=pi_code, VDD=VDD18, VSS=VSS)
    ## FIXME: diff to se driver for `rck` to create output `sclk`
    ## Pre-Amp
    preamp = PreAmp(inp=pads, VDD33=VDD33, VSS=VSS)
    ## Slicers
    slicers = Slicers(inp=preamp.out, rck=rck, data=sdata, edge=edge, VDD18=VDD18, VSS=VSS)
